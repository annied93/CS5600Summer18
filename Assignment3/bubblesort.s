# This is written under the heavy influence of the bubble.s file
# generated by compiler when running bubbblesort.c

# I put in the explanation in comments explaning the steps for the code
.global _swap
.text

_swap:
	pushq	%rbp
	movq	%rsp, %rbp
	movq	%rdi, -24(%rbp)
	movq	%rsi, -32(%rbp)
	movq	-24(%rbp), %rax
	movl	(%rax), %eax
	movl	%eax, -4(%rbp)
	movq	-32(%rbp), %rax
	movl	(%rax), %edx
	movq	-24(%rbp), %rax
	movl	%edx, (%rax)
	movq	-32(%rbp), %rax
	movl	-4(%rbp), %edx
	movl	%edx, (%rax)
	popq	%rbp
	ret

.global _sort
.text
_sort:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$32, %rsp
	movq	%rdi, -24(%rbp)
	movl	%esi, -28(%rbp)
	movl	$0, -4(%rbp)
	jmp 	.L5
.L1:
	movl	$0, -8(%rbp)
	jmp		.L4
.L2:
	movl	-8(%rbp), %eax
	cltq
	leaq	0(,%rax,4), %rdx
	movq	-24(%rbp), %rax
	addq	%rdx, %rax
	movl	(%rax), %edx
	movl	-8(%rbp), %eax
	cltq
	addq	$1, %rax
	leaq	0(,%rax,4), %rcx
	movq	-24(%rbp), %rax
	addq	%rcx, %rax
	movl	(%rax), %eax
	cmpl	%eax, %edx
	jle	.L3
	movl	-8(%rbp), %eax
	cltq
	addq	$1, %rax
	leaq	0(,%rax,4), %rdx
	movq	-24(%rbp), %rax
	addq	%rax, %rdx
	movl	-8(%rbp), %eax
	cltq
	leaq	0(,%rax,4), %rcx
	movq	-24(%rbp), %rax
	addq	%rcx, %rax
	movq	%rdx, %rsi
	movq	%rax, %rdi
	call	_swap
.L3:
	addl	$1, -8(%rbp)
.L4:
	movl	-4(%rbp), %eax
	movl	-28(%rbp), %edx
	subl	%eax, %edx
	movl	%edx, %eax
	subl	$1, %eax
	cmpl 	-8(%rbp), %eax
	jg		.L2
	addl 	$1, -4(%rbp)
.L5:
	movl	-28(%rbp), %eax
	subl	$1, %eax
	cmpl 	-4(%rbp), %eax
	jg		.L1
	leave
	ret

.global _start
.text

_start:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$48, %rsp #make space on the stack for the numbers in the array
	movl	$116, -48(%rbp) #initializing values in the array onto the stack
	movl	$67, -44(%rbp)
	movl	$69, -40(%rbp)
	movl	$102, -36(%rbp)
	movl	$101, -32(%rbp)
	movl	$102, -28(%rbp)
	movl	$111, -24(%rbp)
	movl	$114, -20(%rbp)
	movl	$65, -16(%rbp)
	leaq	-48(%rbp), %rax #put the initial address value of the array into rax
	movl	$9, %esi #put size value into register esi
	movq	%rax, %rdi #put the array pointer into register rdi
	call	_sort
	movl	$0, -4(%rbp)
	movl	$0, -4(%rbp)
	leaq	-52(%rbp), %rbx
	jmp 	.L7
.L6:
	#printing
	movq	$4, %rdx
	addq	%rdx, %rbx
	movq	$1, %rax
	movq	$1, %rdi
	movq	%rbx, %rsi
	syscall
	addl	$1, -4(%rbp)
.L7:
	#check condition for the for loop
	cmpl 	$8, -4(%rbp)
	jle 	.L6
	movl	$0, %eax
	
	#pop registers
	popq	%rdi
	popq	%rsi
	popq	%rdx
	popq	%rbx
	popq	%rax


	#exit
	mov $60, %rax
        xor %rdi, %rdi
        syscall

